<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-12-22 Wed 16:01 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Catkin and Packages</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Matthew Elwin">
<link rel="stylesheet" href="./pubme.css" type="text/css"/>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="./index.html"> HOME </a>
</div><div id="content">
<header>
<h1 class="title">Catkin and Packages</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org632063a">Catkin, the build system for ROS</a></li>
<li><a href="#orgd6dbaa3">Catkin Workspaces</a>
<ul>
<li><a href="#orgaa9330c"><code>install</code> vs <code>devel</code></a></li>
<li><a href="#org2dc7aa2">Building the Workspace</a></li>
<li><a href="#orge78d41c">Creating a workspace</a></li>
</ul>
</li>
<li><a href="#orgd85b888">Activating Workspaces</a>
<ul>
<li><a href="#orgf93d77b">Modifying existing packages</a></li>
</ul>
</li>
<li><a href="#orga1c88ad">Packages</a>
<ul>
<li><a href="#org504ba32">Creating</a></li>
<li><a href="#org2662c58">package.xml</a>
<ul>
<li><a href="#org2a0f66a">Required elements:</a></li>
<li><a href="#org7a7defc">Dependencies</a></li>
</ul>
</li>
<li><a href="#org1e13bf1">CMakeLists.txt</a></li>
<li><a href="#orgddae87b">Package Layout</a></li>
<li><a href="#orgabccbfa">Python Packages</a></li>
<li><a href="#org70010ce">Custom Messages and Services</a>
<ul>
<li><a href="#orgece2284">package.xml</a></li>
<li><a href="#org045b5fd">CMakeLists.txt</a></li>
</ul>
</li>
<li><a href="#orgdac7f99">catkin lint</a></li>
</ul>
</li>
<li><a href="#orgd42124d">Environment Variables</a>
<ul>
<li><a href="#orge8da634">Environment Variable Basics</a></li>
<li><a href="#org4850c73">ROS Environment Variables</a></li>
</ul>
</li>
<li><a href="#org56c7586">rosdep</a></li>
</ul>
</div>
</nav>

<div id="outline-container-org632063a" class="outline-2">
<h2 id="org632063a">Catkin, the build system for ROS</h2>
<div class="outline-text-2" id="text-org632063a">
<ul class="org-ul">
<li><a href="https://wiki.ros.org/catkin">catkin</a> is used to build ROS packages</li>
<li>In-depth documentation is <a href="http://docs.ros.org/noetic/api/catkin/html/index.html">here</a>
<ul class="org-ul">
<li>By following examples you can "get it working" with catkin, but there are many subtleties</li>
<li>Reading the documentation is important for learning the proper way to package programs</li>
</ul></li>
<li>The build process consists of compiling code and converting <code>.msg</code> and <code>.srv</code> files
into code that can be called from <code>python</code> or <code>c++</code></li>
<li>Under the hood, <code>catkin</code> uses <a href="https://cmake.org">cmake</a> to generate build files.  
Thus, each package has a <a href="http://wiki.ros.org/catkin/CMakeLists.txt">CMakeLists.txt</a> file
that is used by <code>cmake</code> to configure the package.</li>
<li><code>cmake</code> is a build-system generator.  Catkin uses <code>cmake</code> to generate <code>Makefiles</code>.  It then
uses <code>make</code> to build your package.</li>
<li><code>catkin</code> also uses <code>package.xml</code> to resolve dependencies during installation and make sure that packages are built in the correct order.
Most dependencies need to be listed both in <code>CMakeLists.txt</code> (so they can be used during the build process)
and in <code>package.xml</code> (so they can be used by the installation process and other ROS tools).</li>
</ul>
</div>
</div>

<div id="outline-container-orgd6dbaa3" class="outline-2">
<h2 id="orgd6dbaa3">Catkin Workspaces</h2>
<div class="outline-text-2" id="text-orgd6dbaa3">
<ul class="org-ul">
<li>Catkin uses <a href="https://wiki.ros.org/catkin/workspaces">workspaces</a> to find your packages</li>
<li>Calling <code>catkin_make</code> in the workspace builds it</li>
<li>A catkin workspace consists of four sub-directories
<ul class="org-ul">
<li><code>src</code> This is the directory with all of your packages.
<ul class="org-ul">
<li>Each subdirectory of <code>src</code> is usually a <code>git</code> repository containing one or more package.</li>
<li>This is the only directory containing files that you edit.</li>
<li>The <code>src</code> directory is sometimes referred to as the <i>source space</i>.</li>
</ul></li>
<li><code>build</code>  All the files generated by <code>cmake</code> go here</li>
<li><code>devel</code> The compiled files go here when the <code>catkin</code> build tool has been run. This directory is
often called the <i>devel</i> space. There are also scripts and</li>
<li><code>install</code> If you install your packages (which can be done via <code>catkin_make install</code>, the files
are placed in the install directory.  Ideally, the <code>install</code> directory contains a full directory tree
with all the files that come with your project and are needed to run your program. This is called the <i>install</i> space.</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgaa9330c" class="outline-3">
<h3 id="orgaa9330c"><code>install</code> vs <code>devel</code></h3>
<div class="outline-text-3" id="text-orgaa9330c">
<ul class="org-ul">
<li>Both spaces (referred to as <i>result spaces</i>) contain files generated from the build</li>
<li>The devel space is designed for quick iteration during development while install is for releases.</li>
<li>The devel space can use different compilation flags (such as debugging) than the install space</li>
<li>The devel space is configured to access python scripts directly from the <code>src</code>.  This means you don't need to rebuild
every time your python code changes.  With the install space, you would need to run <code>catkin_make</code> after every change.
<ul class="org-ul">
<li>However, I recommend running <code>catkin_make</code> as a matter of course when debugging</li>
</ul></li>
<li>The <code>install</code> space can be used to create and distribute your package as a binary.  The ROS packages that
you install using <code>apt</code> have been built by the ROS build farm and packaged as binaries from the install space.</li>
<li>In this class, we will mostly be using the <i>devel</i> space.</li>
</ul>
</div>
</div>

<div id="outline-container-org2dc7aa2" class="outline-3">
<h3 id="org2dc7aa2">Building the Workspace</h3>
<div class="outline-text-3" id="text-org2dc7aa2">
<p>
There are three ROS 1 tools that can be used to build the workspace.
</p>
<ol class="org-ol">
<li><code>catkin_make</code> This is the original tool and the one referred to most commonly.
It is fast because it combines all the packages in the workspace into a single CMake project
before compiling.  We will use this because most documentation still refers to it and it is the fastest.</li>
<li><code>catkin_make_isolated</code>: This tool was created due to  <a href="https://www.ros.org/reps/rep-0134.html">REP-0134</a>.  
Essentially, this builds each package as separate CMake projects, enabling projects that do not use catkin but rather
just use CMake to be built as well. Some projects only build using this tool, and there is a slight preference for it.
<code>catkin_make_isolated</code> uses <code>devel_isolated</code> and <code>install_isolated</code> for the development and install spaces (respectively).</li>
<li><a href="https://catkin-tools.readthedocs.io/en/latest"><code>catkin tools</code></a> can be installed with <code>apt install python3-catkin-tools</code>.
<ul class="org-ul">
<li>It has the cleanest interface of the methods. This tool is technically in Beta and development has stopped; however it works well in practice.</li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-orge78d41c" class="outline-3">
<h3 id="orge78d41c">Creating a workspace</h3>
<div class="outline-text-3" id="text-orge78d41c">
<ul class="org-ul">
<li>Workspaces can be created using <code>mkdir -p &lt;ws_name&gt;/src</code>.
When you run the build tool for the first time, the result spaces will be created.</li>
<li>It makes sense to have separate workspaces for every project you are working on.</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orgd85b888" class="outline-2">
<h2 id="orgd85b888">Activating Workspaces</h2>
<div class="outline-text-2" id="text-orgd85b888">
<ul class="org-ul">
<li>Workspaces are activated by sourcing their <code>setup.bash</code> files</li>
<li>When you installed ROS, you should have added <code>source /opt/ros/melodic/setup.bash</code> to your <code>.bashrc</code>
This line, conceptually, activates a workspace containing all ROS packages that have been installed globally on your system.</li>
<li>Multiple workspaces can be activated at once.  This is called overlaying. See <a href="https://wiki.ros.org/catkin/Tutorials/workspace_overaling">workspace_overalying</a> for details</li>
<li>If multiple workspaces have the same packages, the package in the latest activated workspace takes precedence</li>
<li>To activate your workspace (in particular your devel space), <code>source devel/setup.bash</code> (this is what you will usually do)</li>
<li>You can also activate the install space using <code>source install/setup.bash</code>.</li>
<li>Usually, you will have only two workspaces active, the global system workspace and the one you are working on.
It is recommended to <code>source /opt/ros/melodic/setup.bash</code> in your <code>.bashrc</code> so the global workspace is always active</li>
<li>However, the overlay mechanism allows for advanced uses where different packages/versions can be mixed and matched.  
This feature is useful when, for example, trying to fix a bug in a package that is already installed on your system</li>
<li>We may also use this feature if we need to compile some basic ROS packages that are not yet released for <code>noetic</code></li>
<li>ROS workspaces remember the state they were in when you built the workspace (e.g., ran <code>catkin_make</code>)
<ul class="org-ul">
<li>When you run <code>catkin_make</code> it generates the setup script (e.g. <code>setup.bash</code>).  This script sets your ROS path (i.e., <code>CMAKE_PREFIX_PATH</code>)
to contain all the paths already on it at the time of running <code>catkin_make</code> and a path to the current workspace.</li>
<li>Therefore, you need to make sure you have all workspaces you need sourced prior to running <code>catkin_make</code>.</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgf93d77b" class="outline-3">
<h3 id="orgf93d77b">Modifying existing packages</h3>
<div class="outline-text-3" id="text-orgf93d77b">
<p>
Sometimes, ROS packages have bugs and you want to help fix them.  Sometimes you need a new feature or slightly different behavior from a different package.
The workspace mechanism provides a useful means of handling this case without needing to modify your base system.
</p>
<ol class="org-ol">
<li>Clone the repository you want to work on into the source space of a workspace.
<ul class="org-ul">
<li>Your packages that depend on that package will now use the compiled version, not the version installed on your system.</li>
</ul></li>
<li>Modify the source code to suit your needs.</li>
<li>You can now submit a patch or, if the project is on github, you can fork the main repository, push your changes to your fork, and submit a pull request.</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orga1c88ad" class="outline-2">
<h2 id="orga1c88ad">Packages</h2>
<div class="outline-text-2" id="text-orga1c88ad">
</div>
<div id="outline-container-org504ba32" class="outline-3">
<h3 id="org504ba32">Creating</h3>
<div class="outline-text-3" id="text-org504ba32">
<p>
You create a package using <code>catkin_create_pkg</code>.  
After using this command, you usually need to edit the <code>package.xml</code> and <code>CMakeLists.txt</code>.
</p>
</div>
</div>

<div id="outline-container-org2662c58" class="outline-3">
<h3 id="org2662c58">package.xml</h3>
<div class="outline-text-3" id="text-org2662c58">
<p>
The <code>package.xml</code> is a file describing meta-data about the package.  
It is an <a href="https://www.w3schools.com/xml/default.asp">XML</a> document,
which is specified <a href="https://wiki.ros.org/catkin/package.xml">here</a>.
There is also more information about how to properly write a <code>package.xml</code>
in the <a href="http://docs.ros.org/noetic/api/catkin/html/howto/format2/index.html">catkin documentation</a>.
</p>
</div>

<div id="outline-container-org2a0f66a" class="outline-4">
<h4 id="org2a0f66a">Required elements:</h4>
<div class="outline-text-4" id="text-org2a0f66a">
<ul class="org-ul">
<li><code>&lt;name&gt;</code> The package name</li>
<li><code>&lt;version&gt;</code> The package Version</li>
<li><code>&lt;description&gt;</code> A description of the package</li>
<li><code>&lt;maintainer&gt;</code> One or more people who are responsible for the package</li>
<li><code>&lt;license&gt;</code> One or more legal ways the package may be distributed</li>
</ul>
</div>
</div>

<div id="outline-container-org7a7defc" class="outline-4">
<h4 id="org7a7defc">Dependencies</h4>
<div class="outline-text-4" id="text-org7a7defc">
<p>
There are multiple types of dependencies.  The most important are
</p>
<ul class="org-ul">
<li><code>&lt;exec_depend&gt;</code> - Packages needed at runtime. 
If your python package imports code from another package, or a launchfile runs a node from another package, then
it should be an <code>&lt;exec_depend&gt;</code>, thus this is the most common
dependency for a python-only package.
<ul class="org-ul">
<li>For example, if you <code>import rospy</code> then <code>rospy</code> should be an <code>exec_depend</code></li>
</ul></li>
<li><code>&lt;build_depend&gt;</code> - Package needed at build time.  In python, code is
not compiled, so you usually do not need this.  An exception is when you
depend upon messages or services in another package.</li>
</ul>


<ul class="org-ul">
<li><code>&lt;depend&gt;</code> - This is the most common dependency type for a C++ package.
It should also be used by python packages when depending on packages
containing custom messages such as <code>std_msgs</code>.
Using <code>&lt;depend&gt;</code> automatically creates an <code>&lt;exec_depend&gt;</code> and a <code>&lt;build_depend&gt;</code> (also a <code>&lt;build_export_depend&gt;</code>).
In python especially, whenever you have a <code>&lt;build_depend&gt;</code> you almost always also have an <code>&lt;exec_depend&gt;</code>, so you can just
use <code>&lt;depend&gt;</code>.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org1e13bf1" class="outline-3">
<h3 id="org1e13bf1">CMakeLists.txt</h3>
<div class="outline-text-3" id="text-org1e13bf1">
<ul class="org-ul">
<li>Information on the <a href="http://wiki.ros.org/catkin/CMakeLists.txt">CMakeLists.txt</a> is found here.</li>
<li>The file generated by <code>catkin_create_pkg</code> is well commented, so reading the file helps explain what you need to do.</li>
<li>Change the line with 
<code>find_package(catkin REQUIRED COMPONENTS &lt;dependencies&gt;...)</code>
so that the &lt;dependencies&gt; match whatever is declared as a <code>&lt;depend&gt;</code> in your <code>package.xml</code></li>
<li>You should also change the <code>catkin_package</code> line to include the name of your <code>catkin package</code> dependencies</li>
<li>If you use custom <code>.msg</code> or <code>.srv</code> files, there are further lines to uncomment so that 
the proper code will be generated. There are also lines in <code>package.xml</code> that should be edited.</li>
<li>If you were using C++, you would need to add files to the <code>add_executable</code> statement to compile
your nodes, and the <code>add_library</code> statement to compile your libraries.</li>
<li>There is a section in the auto-generated <code>CMakeLists.txt</code> dedicated to installation.
Lines in this section must be modified to properly be able to install your package.</li>
<li><p>
For each python node and executable script, you should add
</p>
<pre class="example">
catkin_install_python(PROGRAMS nodes/prog1 nodes/prog2 ... DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION})
</pre>
<ul class="org-ul">
<li>This allows you to start your python scripts with the shebang <code>#!/usr/bin/env python3</code> and have catkin replace
it with the proper shebang for the system.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgddae87b" class="outline-3">
<h3 id="orgddae87b">Package Layout</h3>
<div class="outline-text-3" id="text-orgddae87b">
<p>
For a ROS packages, the general layout is as follows, where <code>${ros_pkg}</code> is the base directory of the package
</p>
<ul class="org-ul">
<li>The presence of two files, <code>${ros_pkg}/CMakeLists.txt</code> and <code>${ros_pkg}/package.xml</code> marks a directory as a ROS package</li>
<li><code>${ros_pkg}/scripts</code> executable python scripts (useful utility scripts, not run as nodes).</li>
<li><code>${ros_pkg}/nodes</code> executable python nodes (do not end with <code>.py</code> extension)</li>
<li>The distinction between <code>scripts</code> and <code>nodes</code> is not made in all packages, and is somewhat of a preference
<ul class="org-ul">
<li>Usually <code>scripts</code> is used for executable code that is not a ROS node</li>
<li>In ROS, Python nodes start with a <code>#!/usr/bin/env python</code> and do not end in a <code>.py</code> extension (generally).</li>
<li>They must be installed with <code>catkin_install_python</code> in the <code>CMakeLists.txt</code></li>
</ul></li>
<li><code>${ros_pkg}/src</code> contains python packages and C++ code.</li>
<li><code>${ros_pkg}/msg</code> Message definitions</li>
<li><code>${ros_pkg}/srv</code> Service definitions</li>
</ul>
</div>
</div>
<div id="outline-container-orgabccbfa" class="outline-3">
<h3 id="orgabccbfa">Python Packages</h3>
<div class="outline-text-3" id="text-orgabccbfa">
<ol class="org-ol">
<li>ROS packages can contain one or more python packages. This is useful to allow the distribution of python packages that are tightly related to your ROS code</li>
<li>Let <code>${ros_pkg}</code> be the name of a ROS package, and <code>${py_pkg}</code> be the name of the python package.</li>
<li>Python packages go under <code>${ros_pkg}/src/${py_pkg}</code>. Each ROS package can contain multiple python packages.</li>
<li>Create your python package under <code>${ros_pkg}/src/${py_pkg}</code>. Everything in <code>${py_pkg}</code> works as it does for any other python package.</li>
<li><p>
Create a <code>${ros_pkg}/setup.py</code>. It looks like the following and reads information from the <code>package.xml</code>
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> setuptools <span class="org-keyword">import</span> setup
<span class="org-keyword">from</span> catkin_pkg.python_setup <span class="org-keyword">import</span> generate_distutils_setup
<span class="org-variable-name">d</span> = generate_distutils_setup(
    packages=[<span class="org-string">'${py_pkg}'</span>],
    package_dir={<span class="org-string">''</span>: <span class="org-string">'src'</span>}
    )
setup(**d)
</pre>
</div></li>
<li>Uncomment the <code>catkin_python_setup()</code> line in <code>CMakeLists.txt</code></li>
<li><code>${ros_pkg}/src/${py_pkg}</code>  is just like any other <a href="https://packaging.python.org/tutorials/packaging-projects/">python package</a>
<ul class="org-ul">
<li>It has a <code>src/&lt;pkg&gt;/__init__.py</code>, which can be a blank file most of the time</li>
<li>The package can be imported with <code>import ${py_pkg}</code>.</li>
<li>You can define a python module as <code>src/${py_pkg}/module.py</code> and import it as <code>import ${py_pkg}.module</code></li>
<li><code>catkin</code> takes care of the python path for you. If you have trouble importing a module, it is likely an issue with the <code>catkin</code> setup</li>
</ul></li>
<li>Moving code into a python package (as opposed to leaving all code in the node) has several advantages
<ol class="org-ol">
<li>You can import it into the <code>python</code> interpreter and work with it interactively</li>
<li>It is easier to test</li>
<li>It is easier to document (<code>sphinx autodoc</code> generally only documents packages not executable python files)</li>
</ol></li>
<li>See the catkin documentation for more details:
<ul class="org-ul">
<li><a href="http://docs.ros.org/en/noetic/api/catkin/html/user_guide/setup_dot_py.html">Python Setup File</a></li>
<li><a href="http://docs.ros.org/noetic/api/catkin/html/howto/format2/installing_python.html">Installing Python</a></li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-org70010ce" class="outline-3">
<h3 id="org70010ce">Custom Messages and Services</h3>
<div class="outline-text-3" id="text-org70010ce">
<p>
To create custom ROS <a href="https://wiki.ros.org/msg">message</a> and <a href="https://wiki.ros.org/srv">service</a> types, edit <code>CMakeLists.txt</code> and <code>package.xml</code>.
</p>

<p>
Conceptually there are three pieces required to generate messages and services:
</p>
<ol class="org-ol">
<li>Bring in all of the <code>catkin</code> machinery required to generate messages in general</li>
<li>Make <code>catkin</code> aware of all of the dependencies of your message/service</li>
<li>Tell <code>catkin</code> to process your message/service files and turn them into <code>C++</code> and <code>python</code> code that can be used in your programs.</li>
</ol>
</div>

<div id="outline-container-orgece2284" class="outline-4">
<h4 id="orgece2284">package.xml</h4>
<div class="outline-text-4" id="text-orgece2284">
<ol class="org-ol">
<li>You must <code>&lt;build_depend&gt;</code> on <code>message_generation</code>: this ROS package generates the required code from <code>.msg</code> and <code>.srv</code> files</li>
<li>You must <code>&lt;exec_depend&gt;</code> on <code>message_runtime</code>: this ROS package allows your code to use custom messages at runtime</li>
<li>You must <code>&lt;depend&gt;</code> on any of the packages that your <code>.msg</code> or <code>.srv</code> require
<ul class="org-ul">
<li>Any type that is not one of the built-in types (listed <a href="https://wiki.ros.org/msg">here</a>) is specified
as <code>&lt;pkg&gt;/Type</code> in the <code>.msg</code> or <code>.srv</code> file.  These <code>&lt;pkg&gt;</code> names are the dependencies</li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org045b5fd" class="outline-4">
<h4 id="org045b5fd">CMakeLists.txt</h4>
<div class="outline-text-4" id="text-org045b5fd">
<ol class="org-ol">
<li>Make <code>CMake</code> aware of message generation and your message dependencies
<ul class="org-ul">
<li>Modify the <code>find_package(catkin REQUIRED)</code> line to list these dependencies as components</li>
<li>It should look like <code>find_package(catkin REQUIRED message_generation &lt;dep1&gt; ... &lt;depn&gt;)</code>, where the dependencies
are the dependencies for the messages that you want to generate</li>
</ul></li>
<li>Tell <code>CMake</code> about the files you want to generate
<ul class="org-ul">
<li>Uncomment <code>add_message_files</code> and <code>add_service_files</code> as needed.</li>
<li>These functions expect your <code>.msg</code> files to be in <code>&lt;pkg&gt;/msg</code> and <code>.srv</code> files to be in <code>&lt;pkg&gt;/srv</code></li>
</ul></li>
<li>Tell <code>CMake</code> to generate the code
<ul class="org-ul">
<li>Uncomment the <code>generate_messages</code> line and add any message dependencies to the <code>DEPENDENCIES</code> in that call</li>
</ul></li>
<li>Add <code>message_runtime</code> and your message dependencies to <code>catkin_package(CATKIN_DEPENDS)</code>. This line enables
other <code>catkin</code> packages to easily import your messages</li>
<li>See the ROS tutorial on <a href="http://wiki.ros.org/ROS/Tutorials/CreatingMsgAndSrv">Creating ROS msg and srv</a>.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgdac7f99" class="outline-3">
<h3 id="orgdac7f99">catkin lint</h3>
<div class="outline-text-3" id="text-orgdac7f99">
<ul class="org-ul">
<li><a href="https://fkie.github.io/catkin_lint">catkin_lint</a> is a tool used to help check that your <code>CMakeLists.txt</code> and <code>package.xml</code>
have the required information and are synchronized.</li>
<li>Install via <code>apt install python-catkin-lint</code></li>
<li>There is much redundancy between <code>package.xml</code> and <code>CMakeLists.txt</code>, and these files must be kept synchronized
<ul class="org-ul">
<li>It is very easy, for example, to require a dependency in CMakeLists.txt but not put it in your <code>package.xml</code>
This will have consequences when distributing your package, such as <code>rosdep</code> not being aware of all dependencies.</li>
<li>The procedure to add custom messages and services is quite tedious, but <code>catkin_lint</code> not only detects errors
in this setup but often tells you exactly what you need to do to fix them.</li>
</ul></li>
<li><code>catkin_lint src</code> will check all the packages in your source space, or you can check an individual package by providing
the path to that package</li>
<li>I recommend using this tool on all your packages and fixing any errors it points out</li>
<li>Most of the time, your package, especially if written in python, will work even if failing these checks;
however, heeding checks helps ensure that other people won't have problems when trying to use your package.</li>
<li>You can see an explanation for the warnings with the <code>catkin_lint --explain</code> option</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd42124d" class="outline-2">
<h2 id="orgd42124d">Environment Variables</h2>
<div class="outline-text-2" id="text-orgd42124d">
<p>
Environment Variables are used in Linux to control the behavior of programs.
</p>
</div>
<div id="outline-container-orge8da634" class="outline-3">
<h3 id="orge8da634">Environment Variable Basics</h3>
<div class="outline-text-3" id="text-orge8da634">
<ul class="org-ul">
<li>See all environment variables using <code>env</code></li>
<li>See all ROS environment variables using <code>env | grep ROS</code>, the <code>| grep ROS</code> part filters for variables containing the word ROS</li>
<li>A scrollable list of environment variables is obtained using <code>env | less</code>. Press <code>h</code> for help and <code>q</code> for quit.</li>
<li>The value of an individual variable can be printed using <code>printenv VARNAME</code></li>
<li><code>unset VARNAME</code> clears an environment variable.</li>
<li><p>
The value can also be retrieved by prefixing the name with a <code>$</code>.  
</p>
<pre class="example">
&gt; export VAR = 2
&gt; echo "Hello $VAR"
Hello 2
</pre></li>
<li>Each terminal has a different set of variables. Changing a variable in one terminal does not affect the other terminals.</li>
<li>To set an environment variable "globally", add an <code>export</code> line to <code>~/.bashrc</code>
The commands in <code>~/.bashrc</code> are run whenever your shell (the program that runs your commands entered at the command-line) starts.
Thus every time you open the <code>Terminal</code> the variables that you set in <code>.bashrc</code> will be set.</li>
<li>For more information see <a href="https://nu-msr.github.io/hackathon_site/linux_intro.html">Linux Introduction</a></li>
</ul>
</div>
</div>
<div id="outline-container-org4850c73" class="outline-3">
<h3 id="org4850c73">ROS Environment Variables</h3>
<div class="outline-text-3" id="text-org4850c73">
<p>
ROS relies on several <a href="https://wiki.ros.org/ROS/EnvironmentVariables">environment variables</a> to work.
</p>
<ul class="org-ul">
<li>Running <code>source /opt/ros/melodic/setup.bash</code> in your <code>~/.bashrc</code> sets the ROS variables to their initial values every time you start <code>bash</code>.</li>
<li>When you activate the workspace using <code>source devel/setup.bash</code> you are primarily setting environment variables related to ROS</li>
<li><code>ROS_ROOT</code> stores the path to the core ROS packages</li>
<li><code>ROS_MASTER_URI</code> stores the location of rosmaster.  By default this is <code>http://localhost:11311</code>.</li>
<li><code>PYTHONPATH</code> this tells python where to find packages. Sourcing  <code>devel/setup.bash</code> sets this up properly for use with ROS.
Modifying the python path to fix a problem is likely the incorrect action when using ROS.</li>
<li><code>CMAKE_PREFIX_PATH</code> tells CMake where to find everything required to build a cmake project. 
This is also <a href="http://wiki.ros.org/catkin/conceptual_overview#Difference_in_rosbuild_and_catkin_Environment_Setup_Files_and_Environment_Variables">used by catkin</a>
to find all of your packages and is set by <code>setup.bash</code>.</li>
<li><code>ROS_IP/ROS_HOSTNAME</code> Optional variables used for running nodes over the network.  <code>ROS_IP</code> specifies the ip address for a node that is launched
and <code>ROS_HOSTNAME</code> specifies the hostname for a node that is launched. <b>Never set both of these</b> as <code>ROS_HOSTNAME</code> overrides <code>ROS_IP</code>.  
If the computer you are running nodes on is accessible via hostname lookup from other computers on your network, you do not need to set these at all.
<ul class="org-ul">
<li>My recommendation is to always set up the network properly.</li>
<li>When buying a router, find one supported by <a href="https://openwrt.org/">https://openwrt.org/</a>, which automatically allows name resolution on a local network.</li>
<li>If all computers in a network run the <code>avahi-daemon</code>, then they should be able to resolve each other as <code>&lt;hostname&gt;.local</code>.</li>
</ul></li>
<li><code>ROS_PACKAGE_PATH</code> is a legacy variable that is not actually used; however, it will show the paths to your overlayed workspaces and is useful for debugging</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org56c7586" class="outline-2">
<h2 id="org56c7586">rosdep</h2>
<div class="outline-text-2" id="text-org56c7586">
<p>
<a href="https://wiki.ros.org/rosdep">rosdep</a> is ROS's tool for installing system dependencies and released ROS packages.  
</p>
<ul class="org-ul">
<li>It is installed with <code>sudo apt install python3-rosdep</code>.</li>
<li><code>rosdep</code> relies on <i>keys</i>, generic names for packages that it can then download using various system package managers.</li>
<li>The list of keys is defined according to the <a href="http://docs.ros.org/independent/api/rosdep/html/rosdep_yaml_format.html">rosdep YAML specification</a>.</li>
<li>The YAML files for each ROS distribution are <a href="https://github.com/ros/rosdistro">stored here</a></li>
<li>To automatically install system dependencies for a package whose source code you have downloaded
you would do <code>rosdep install --from-paths &lt;workspace&gt;/src --ignore-src --rosdistro=melodic</code>.</li>
<li>If you add the <code>-s</code> flag <code>rosdep</code> will tell you what it will install without actually doing it.</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p><p class="outline-2">Author: Matthew Elwin</p></p>
</div>
</body>
</html>
